package edu.caltech.nanodb.plannodes;


import java.io.IOException;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

import edu.caltech.nanodb.expressions.Expression;
import edu.caltech.nanodb.expressions.FunctionCall;
import edu.caltech.nanodb.expressions.OrderByExpression;
import edu.caltech.nanodb.expressions.TupleLiteral;

import edu.caltech.nanodb.queryeval.PlanCost;

import edu.caltech.nanodb.relations.Tuple;


/**
 * Implements grouping and aggregation by using sorting as a method to find
 * groups.
 */
public class SortedGroupAggregateNode extends GroupAggregateNode {
    /** A logging object for reporting anything interesting that happens. */
    private static Logger logger = Logger.getLogger(SortedGroupAggregateNode.class);

    private List<OrderByExpression> orderByExprs;

    private boolean done;


    /**
     * A tuple of the current group-by values being considered.  When each
     * tuple is retrieved from the subplan, a set of group-by values is
     * computed, and if it matches this set of group-by values then we are
     * still in the same group; otherwise, we have moved to the next group.
     */
    private TupleLiteral currentGroupValues;


    public SortedGroupAggregateNode(PlanNode subplan,
        List<Expression> groupByExprs, Map<String, FunctionCall> aggregates) {
        super(subplan, groupByExprs, aggregates);

        // Compute the order-by expressions based on the grouping expressions.
        orderByExprs = new ArrayList<OrderByExpression>();
        for (Expression expr : groupByExprs)
            orderByExprs.add(new OrderByExpression(expr));

        // TODO:  Verify that this node's order-by expressions are compatible
        //        with the subplan's order-by expressions!  In other words, if
        //        the subplan isn't ordered on the same expressions, we can't
        //        successfully use this plan node; a hashing group/aggregate
        //        plan node must be used instead.
    }


    @Override
    public boolean equals(Object obj) {
        if (obj instanceof SortedGroupAggregateNode) {
            SortedGroupAggregateNode other = (SortedGroupAggregateNode) obj;

            return groupByExprs.equals(other.groupByExprs) &&
                   aggregates.equals(other.aggregates) &&
                   leftChild.equals(other.leftChild);
        }
        return false;
    }


    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + groupByExprs.hashCode();
        hash = 31 * hash + aggregates.hashCode();
        hash = 31 * hash + leftChild.hashCode();
        return hash;
    }


    // Use parent javadocs.
    @Override
    public String toString() {
        return "SortedGroupAggregate[groupBy=" + groupByExprs +
            ", values=" + aggregates + "]";
    }


    /**
     * The sorted grouping/aggregate operation orders its results according
     * to the columns in the GROUP BY clause.
     */
    public List<OrderByExpression> resultsOrderedBy() {
        return orderByExprs;
    }


    /**
     * The sorted grouping/aggregate operation does not support marking, since
     * it must fully consume its input before it can produce any results.
     */
    public boolean supportsMarking() {
        return false;
    }


    /**
     * The sorted grouping/aggregate operation does not require marking.
     */
    public boolean requiresLeftMarking() {
        return false;
    }


    /**
     * The sorted grouping/aggregate operation does not require marking.
     */
    public boolean requiresRightMarking() {
        return false;
    }


    /**
     * Gets the next tuple that fulfills the conditions for this plan node.
     * If the node has a child, it should call getNextTuple() on the child.
     * If the node is a leaf, the tuple comes from some external source such
     * as a table file, the network, etc.
     *
     * @return the next tuple to be generated by this plan, or <tt>null</tt>
     *         if the plan has finished generating plan nodes.
     *
     * @throws java.io.IOException if table data cannot be read from the filesystem
     * @throws IllegalStateException if a plan node is not properly initialized
     */
    public Tuple getNextTuple() throws IllegalStateException, IOException {
        if (done)
            return null;

        TupleLiteral result = null;
        Tuple inputTuple;

        // Traverse the subplan's tuples, generating the group and aggregate
        // values for the current group.
        while ((inputTuple = leftChild.getNextTuple()) != null) {
            environment.clear();
            environment.addTuple(inputSchema, inputTuple);

            TupleLiteral groupValues = evaluateGroupByExprs();

            // Note:  I unpin in each branch of the if statement, because the
            // logic is a bit easier to follow than if I try to factor out
            // common code.  Just make sure tuples always get unpinned...

            if (groupValues.equals(currentGroupValues)) {
                // Still in the same group.  Update the aggregates.
                updateAggregates(aggregates);

                // Done with the current tuple, so unpin it.
                inputTuple.unpin();
            }
            else {
                if (currentGroupValues != null) {
                    // The previous group is finished now.  Generate the tuple
                    // we will output.  Don't return it right away, because we
                    // need to start the next group before returning.
                    result = generateOutputTuple(currentGroupValues, aggregates);
                }

                // Start the next group.
                currentGroupValues = groupValues;

                // Re-initialize the aggregates collection
                clearAggregates(aggregates);
                updateAggregates(aggregates);

                // Done with the current tuple, so unpin it.
                inputTuple.unpin();

                // Return the output tuple for the group we just finished.
                return result;
            }
        }

        // If we got here then the subplan is out of tuples.  If we currently
        // have a group in progress, output that result, then we're done.
        if (currentGroupValues != null) {
            result = generateOutputTuple(currentGroupValues, aggregates);

            // Clear these values, just to be clean/safe.  (Nothing depends on
            // this, as far as I know...)
            clearAggregates(aggregates);
            currentGroupValues = null;
        }

        done = true;
        return result;
    }


    public void prepare() {
        // Need to prepare the left child-node before we can do our own work.
        leftChild.prepare();

        // Use the helper function to prepare the schema of this grouping/aggregate
        // plan-node, since it is a complicated operation.
        prepareSchemaStats();

        // Grab the left child's cost, then update the cost based on the cost
        // of sorting and computing aggregates.
        PlanCost childCost = leftChild.getCost();
        if (childCost != null) {
            cost = new PlanCost(childCost);

            // Since we expect the child plan-node to produce its tuples in
            // sorted order, the cost of this plan-node is constant-time per
            // tuple.
            cost.cpuCost += cost.numTuples;

            // The actual number of tuples generated by this plan-node is equal
            // to the number of groups we have, so just use the estimate we
            // computed earlier.
            cost.numTuples = estimatedNumTuples;

            // Assume that computing each aggregate value costs one unit.
            cost.cpuCost += estimatedNumTuples * aggregates.size();
        }
        else {
            logger.info(
                "Child's cost not available; not computing this node's cost.");
        }

        // TODO:  Estimate the final tuple-size.  It isn't hard, just tedious.
    }


    /**
     * Does any initialization the node might need.  This could include
     * resetting state variables or starting the node over from the beginning.
     *
     */
    public void initialize() {
        super.initialize();

        orderByExprs = null;
        done = false;
        currentGroupValues = null;

        leftChild.initialize();
    }


    /**
     * The sorted grouping/aggregate plan node doesn't support marking.
     *
     * @throws UnsupportedOperationException always.
     */
    public void markCurrentPosition() throws UnsupportedOperationException {
        throw new UnsupportedOperationException(
            "Sorted grouping/aggregate node doesn't support marking");
    }


    /**
     * The sorted grouping/aggregate plan node doesn't support marking.
     *
     * @throws UnsupportedOperationException always.
     */
    public void resetToLastMark() {
        throw new UnsupportedOperationException(
            "Sorted grouping/aggregate node doesn't support marking");
    }


    /**
     * Perform any necessary clean up tasks. This should probably be called
     * when we are done with this plan node.
     */
    public void cleanUp() {
        currentGroupValues = null;
        leftChild.cleanUp();
    }
}
